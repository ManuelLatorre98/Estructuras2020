!SESSION 2021-03-27 09:29:15.099 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\manul\eclipse-workspace\.metadata\.bak_0.log
Created Time: 2021-03-27 12:40:10.721

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:40:10.721
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:40:10.722
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:40:13.279
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getPuestosEmbarque())+1)+(this.puestosEmbarque*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:40:13.280
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:40:13.280
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:40:17.345
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getPuestosEmbarque().length)+1)+(this.puestosEmbarque*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:40:17.346
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:40:17.346
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:41:06.994
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getPuestosEmbarque().length)+1)+(this.puestosEmbarque*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:41:06.995
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:41:06.995
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:41:11.613
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getPuestosEmbarque().length)+1)+(this.puestosEmbarque*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-03-27 12:41:11.614
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-03-27 12:41:11.614
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:41:13.048
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].get)+1)+(this.puestosEmbarque*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:41:13.049
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:41:13.049
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:41:15.103
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.puestosEmbarque*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:41:15.104
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:41:15.104
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:41:20.853
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.puestosEmbarque*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-03-27 12:41:20.853
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-03-27 12:41:20.854
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:41:25.660
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:41:25.661
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:41:25.661
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:49:34.067
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-03-27 12:49:34.067
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-03-27 12:49:34.068
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:49:46.958
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=(((int)(Math.random()*7)+1));//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-03-27 12:49:46.958
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-03-27 12:49:46.959
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:49:55.725
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));;//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:49:55.726
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:49:55.726
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:49:58.096
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));;//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-03-27 12:49:58.097
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-03-27 12:49:58.097
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-03-27 12:50:00.777
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package TPOFinal;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Aeropuerto {
	private Terminal[]terminales;//Recibe por parametro, Las terminales estan asociadas con el nro de reserva
	private Reloj reloj;//Dato compartido
	private String horaApertura;
	private String horaCierre;
	private int horaAperturaInt;//En minutos
	private int horaCierreInt;//En minuto
	
	boolean abierto=false;
	private PuestoAtencion[]puestosAten;
	
	//CentroInformes
	private Semaphore semCentroInf=new Semaphore (0,true);
	private Semaphore semAtencionCentroInf=new Semaphore(0,true);
	private Semaphore mutexCentroInf=new Semaphore(1,true);
	private Semaphore mutexCentroInfDatos=new Semaphore(1,true);
	private BlockingQueue <Pasajero> colaCentroInf = new LinkedBlockingQueue<Pasajero>();//Cola ilimitada
	
	//Tren
	int capacidadTren=10;//La responsabilidad de setear esto creo que deberia ser del thread tren o directamente el tren deberia dar dicha info, lo seteo asi para no enrredar tanto
	private Lock lock;
	private Condition esperaPasajeros;
	private Condition esperaTren;
	private Condition esperaArranque;
	private boolean enMarcha=false;
	private CyclicBarrier barrierStartTren=new CyclicBarrier(capacidadTren);
	private int[]cantPasajerosTerminal;
	private Condition viajando;
	private int cantPasajerosEsp=0;
	private char letraTerminalActual='0';//De origen
	private int cantPasajerosEnTren=0;
	
	
	public Aeropuerto(String horaApertura, String horaCierre,Reloj reloj, Terminal []terminales) {
		this.terminales=terminales;
		this.horaApertura=horaApertura;
		this.horaCierre=horaCierre;
		this.reloj=reloj;
		this.horaAperturaInt=reloj.traducirHora(horaApertura);
		this.horaCierreInt=reloj.traducirHora(horaCierre);
		
		this.puestosAten=new PuestoAtencion[this.terminales.length];//Voy a tener 1 centro de atencion por plataforma/aerolinea
		this.crearCentrosAtencion();
		
		this.lock=new ReentrantLock(true);
		this.esperaPasajeros=this.lock.newCondition();
		this.esperaTren=this.lock.newCondition();
		this.esperaArranque=this.lock.newCondition();
		this.viajando=this.lock.newCondition();
		this.cantPasajerosTerminal=new int[this.terminales.length];
		
	}
	
	//Operaciones Aeropuerto
	
	private void crearCentrosAtencion() {//Un centro por aerolinea plataforma
		for (int i = 0; i < this.terminales.length; i++) {
			this.puestosAten[i]=new PuestoAtencion((i+1),this);//Los centros de atencion se identifican por su plataforma/aerolinea
		}
	}

	public PuestoAtencion[]getListaPuestosAtencion(){
		return this.puestosAten;
	}
	public PuestoAtencion getPuestoAtencion(int nroPuesto) {
		PuestoAtencion puestoAten=null;
		try {
			this.mutexCentroInfDatos.acquire();
			puestoAten=this.puestosAten[nroPuesto];
			this.mutexCentroInfDatos.release();
		}catch(InterruptedException e) {}
		return puestoAten;
	}
	
	public Terminal getTerminal(int nro) {
		return this.terminales[nro];
	}
	
	public int ubicarTerminal(Terminal terminal) {
		boolean encontrado=false;
		int pos=-1;
		int i=0;
		while(!encontrado && i<this.terminales.length) {
			if(this.terminales[i].equals(terminal)) {
				pos=i;
				encontrado=true;
			}
			i++;
		}
		return pos;
	}

	
	//OPERACIONES PASAJERO
	public synchronized void intentoEntradaAeropuerto() {
		try {
			while(!abierto) {
				this.wait();
			}
		}catch(InterruptedException e) {}
	}
	
	public void entrarAeropuerto(Pasajero pasajero) {//La reserva se le asignaba cuando llego al aeropuerto por eso lo hago aca
		int nroReserva=(int)(Math.random()*this.terminales.length)+1;//El nro de reserva va por aerolinea/plataforma
		int puestoTerminal=0;//Define el puesto de embarque, 1 puesto de embarque por vuelo, 7 vuelos por aerolinea/plataforma,
		Reserva reserva;
		puestoTerminal=((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));;//Obtengo el embarque de 1 a puestosEmbarque y lo asigno a su plataforma con la suma
		reserva=new Reserva(nroReserva,this.terminales[nroReserva-1].getPuestoEmbarque(puestoTerminal).getNroPuesto());
		pasajero.setReserva(reserva);
		//((int)(Math.random()*this.puestosEmbarque)+1)+(this.puestosEmbarque*(nroReserva-1));
		((int)(Math.random()*this.terminales[nroReserva].getCantidadPuestosEmbarque())+1)+(this.terminales[nroReserva].getCantidadPuestosEmbarque()*(nroReserva-1));
	}
	
	public void esperaAtencionCentroInf(Pasajero pasajero) {
		try {
			this.mutexCentroInf.acquire();//El lock de la blocking queue va tan rapido que los hilos llegan al semaforo en orden distinto al que entran en cola
			Thread.sleep(1);//Con esto hago que entren con una diferencia de 1ms a la cola y por lo tanto al semaforo lleguen en el orden que entraron a la cola
			this.mutexCentroInf.release();
			this.colaCentroInf.put(pasajero);//Pongo una referencia a si mismo en la cola
			
			this.semCentroInf.acquire();//Queda loqueado hasta que le digan que puede pasar
		;
		
		}catch(InterruptedException e) {}
	}
	
	public void pasarCentroInf() {
		try {
			this.semAtencionCentroInf.acquire();//Queda lockeado hasta que lo liberan
		}catch(InterruptedException e) {}
	}
	
	public void esperarTren() {
		this.lock.lock();
		while(enMarcha || this.cantPasajerosEnTren==this.capacidadTren) {//Mientras el tren esta en marcha o esta lleno los pasajeros esperan
			try {
				this.esperaTren.await();
			}catch(InterruptedException e) {};
		}
		
		if(this.cantPasajerosEsp==0) {//El primero inidica si hay pasajeros esperando
			this.cantPasajerosEsp++;
			this.esperaPasajeros.signal();
		}
		this.cantPasajerosEnTren++;//Se va a subir al tren asi que suma uno
		this.lock.unlock();
	}
	
	public void indicarTerminalParada(Terminal terminalAsignada){
		int posTerminal;
		this.lock.lock();
		posTerminal=this.ubicarTerminal(terminalAsignada);//La terminal y por lo tanto su letra corresponde a una posicion del arreglo de terminales del aeropuerto
		this.cantPasajerosTerminal[posTerminal]=this.cantPasajerosTerminal[posTerminal]+1;//pos 0=terminalA, pos1=terminalB, etc.
		//System.out.println("PASAJEROS DENTRO DEL TREN "+this.barrierStartTren.getNumberWaiting());//Lo pongo aca para aprovechar el lock
		this.lock.unlock(); 
	}
	
	
	public void tomarTren() {
		
		try {	
			this.barrierStartTren.await(15000,TimeUnit.MILLISECONDS);//Espera a que el tren este lleno o pase el tiempo
		}catch(InterruptedException e) {
		}catch(BrokenBarrierException e) {
		}catch(TimeoutException e) {//Suponogo que viene para aca con el timeout
		}
	
		
		
	}
	
	public void viajarEnTren(Terminal terminalAsignada) {
		this.lock.lock();
		if(!this.enMarcha) {//Si el tren sigue parado
			this.enMarcha=true;//Indica que se puede poner en marcha
			this.esperaArranque.signal();//Le avisa al tren que puede arrancar ya sea porque se libero la barrier por capacidad o tiempo
		}
		this.cantPasajerosEsp--;//Indica que ya no esta esperando
		while(this.letraTerminalActual!=terminalAsignada.getLetraTerminal()) {//Mientras el tren no haya parado en su terminal espera
			try {
				this.viajando.await();
			}catch(InterruptedException e) {}
		}
		this.cantPasajerosEnTren--;//Se baja del tren asi que hay uno menos
		this.lock.unlock();
		
		
	}
	

	
	//Operaciones centroInformes
		public void atiendeCentro(CentroInformes centro) {
			Pasajero pasajero=null;
			
			try {
				Thread.sleep(10);//Para que salgan mensajes en orden y quede claro en testeo
				pasajero=(Pasajero)this.colaCentroInf.take();//Saca la referencia del cliente de la cola, si esta vacia queda bloqueado
			
			}catch(InterruptedException e) {}
				//System.out.println("PASAJEROOOOOOOOOOOOOO"+pasajero.getNombre());//Prueba que atiende al que saca de la lista junto con mensaje en centroInforems.atenderCliente(). con un sleep de 500 antes del take se ven mensajes en orden
				this.semCentroInf.release();//Avisa a un hijo que puede pasar
				
				//El setPuestoAten tiene mas sentido que se haga en centroInformes o aca?
				
				centro.atenderCliente(pasajero);//Atiende al pasajero y se lleva la referencia de los centros de atencion para poder trabajar
				this.semAtencionCentroInf.release();
		}
	
	//Operaciones del tren
	public void recogerPasajeros() {
		lock.lock();
		
		while(this.cantPasajerosEsp==0) {//Mientras no haya pasajeros espera, el primer pasajero que llegue le avisa
			try {
				this.esperaPasajeros.await();
			}catch(InterruptedException e) {}
		}
		
		while(!enMarcha) {//Mientras esta parado recogiendo pasajeros espera
			try {
				this.esperaArranque.await();
			}catch(InterruptedException e) {}
		}

		lock.unlock();
	}
	
	public void transportar(Tren tren) {
		boolean hayPasajeros;
		//El for no lo protejo porque me retiene el lock y cuando hago signalAll solo le llega para los pasajeros de la ultima estacion
		//de todas maneras la cantidad de terminales no se tendria que ver modificada en ningun momento por lo que no se seria necesario 
		//Asegurar exclusion mutua ya que los hilos solo acceden a esta y siempre tiene un estado fijo
		for (int i = 0; i < this.terminales.length; i++) {//Recorre terminal por terminal
			lock.lock();
			tren.viajar(this.terminales[i].getLetraTerminal());//Viaja
			hayPasajeros=this.cantPasajerosTerminal[i]>0;//Lo hago asi para que los mensajes salgan en orden
			lock.unlock();
			
			if(hayPasajeros) {//Si hay pasajeros que quieren bajar en esa terminal el tren frena y les avisa
				lock.lock();
				this.letraTerminalActual=this.terminales[i].getLetraTerminal();//Indico en que terminal esta parado el tren
				this.viajando.signalAll();//Avisa a todos los pasajeros que bajo en una terminal, ellos decidiran si les corresponde o no
				lock.unlock();
				//Antes era todo un solo lock y salia a destiempo el mensaje de para del tren con la bajada de los pasajeros
				lock.lock();
				tren.frenarTerminal(this.terminales[i].getLetraTerminal(), this.cantPasajerosTerminal[i]);//se liberaban antes 1,5seg despues de este mensaje porque el lock sigue siendo del tren 
				this.cantPasajerosTerminal[i]=0;//inidico que no quedan pasajeros para bajar en esa terminal para la vuelta
				lock.unlock();
			}
			
		}	
	}
	
	public void volverOrigen(Tren tren) {
		lock.lock();
		tren.viajar('0');//Viaja de vuelta al origen
		this.letraTerminalActual='0';
		this.enMarcha=false;//Cuando termina de recorrer todas las terminales indica que no estan en marcha
		this.esperaTren.signalAll();//Le avisa a todos los pasajeros que ya llego
		lock.unlock();
	}

	
	
	//Operaciones GestorHora
	public synchronized void revicionHora() {//Luego de actualizarse la hora se notifica por si estaba cerrado y pasa a estar abierto
		if(!abierto && this.reloj.getHoraInt()>=this.horaAperturaInt && this.reloj.getHoraInt()<=this.horaCierreInt) {//Si estaba cerrado y es hora de abrir notifica
			this.abierto=true;
			this.notifyAll();
		}
	}
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-03-27 12:50:00.777
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-03-27 12:50:00.779
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-03-28 08:40:33.605 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-03-28 08:40:37.168
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-03-28 08:40:37.168
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f166d61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5896b9f5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-03-28 08:40:43.479
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-03-29 10:01:41.923 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-03-29 10:01:45.533
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-03-29 10:01:45.533
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5896b9f5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ad8d36f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-03-29 10:01:51.819
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-03 10:35:12.770 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-03 10:35:16.357
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-03 10:35:16.357
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7fb82f73,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f166d61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-03 10:35:22.938
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-03 11:05:16.957 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-03 11:05:19.685
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-03 11:05:19.685
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ad8d36f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74a5bef0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-03 11:05:25.005
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-07 10:57:22.013 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-07 10:57:25.840
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-07 10:57:25.840
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f166d61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5896b9f5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-07 10:57:32.461
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-08 10:37:29.049 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-08 10:37:32.495
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-08 10:37:32.495
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f655dbd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@546083d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-08 10:37:38.740
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.jobs 2 2 2021-04-08 11:38:06.460
!MESSAGE Job found still running after platform shutdown.  Jobs should be canceled by the plugin that scheduled them during shutdown: org.eclipse.jdt.internal.core.search.processing.JobManager$1ProgressJob
!SESSION 2021-04-12 11:23:36.317 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-12 11:23:40.833
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-12 11:23:40.833
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@570ed9c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@93f15f6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-12 11:23:47.933
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-13 10:46:14.119 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-13 10:46:17.928
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-13 10:46:17.928
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74a5bef0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@68c4a860,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-13 10:46:24.861
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-15 09:13:46.186 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-15 09:13:50.504
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-15 09:13:50.504
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d0e703a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f77e065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-15 09:13:58.655
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-15 10:14:48.665 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-15 10:14:51.421
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-15 10:14:51.421
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32513dea,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d0e703a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-15 10:14:56.600
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-16 10:08:34.649 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-16 10:08:38.235
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-16 10:08:38.235
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d0e703a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f77e065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-16 10:08:44.390
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-16 10:57:12.113 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-16 10:57:14.988
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-16 10:57:14.988
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d0e703a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f77e065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-16 10:57:21.067
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-16 13:58:37.706 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-16 13:58:41.445
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-16 13:58:41.445
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d0e703a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f77e065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-16 13:58:47.414
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-17 09:58:06.798 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-17 09:58:10.472
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-17 09:58:10.472
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f655dbd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@546083d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-17 09:58:16.884
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-19 09:42:09.871 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-19 09:42:13.393
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-19 09:42:13.393
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f77e065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f655dbd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-19 09:42:20.385
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-19 09:55:27.412 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-19 09:55:30.214
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-19 09:55:30.214
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53a09566,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1c815814,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-19 09:55:35.829
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-21 10:17:51.530 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-21 10:17:55.998
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-21 10:17:55.998
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@546083d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ac1b6c0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-21 10:18:03.085
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2021-04-21 11:53:55.311
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IndexOutOfBoundsException: Index 14 out of bounds for length 14
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)
	at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:248)
	at java.base/java.util.Objects.checkIndex(Objects.java:373)
	at java.base/java.util.ArrayList.get(ArrayList.java:425)
	at java.base/java.util.Collections$SynchronizedList.get(Collections.java:2426)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.selectProposal(CompletionProposalPopup.java:1414)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1352)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:809)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1769)
	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:5168)
	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:406)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4791)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2021-04-21 14:29:46.046 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-21 14:29:50.398
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-21 14:29:50.398
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7fb82f73,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f166d61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-21 14:29:56.777
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-22 10:29:04.009 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-22 10:29:07.935
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-22 10:29:07.935
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@546083d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ac1b6c0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-22 10:29:14.506
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-20 10:51:39.271 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-20 10:51:44.613
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-20 10:51:44.613
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6e67a8c0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5960f17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.equinox.app 4 2 2021-05-20 10:51:51.007
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.equinox.app".
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4869)
	at org.eclipse.swt.SWT.error(SWT.java:4784)
	at org.eclipse.swt.SWT.error(SWT.java:4755)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:351)
	at org.eclipse.swt.widgets.Shell.close(Shell.java:547)
	at org.eclipse.ui.splash.AbstractSplashHandler.dispose(AbstractSplashHandler.java:65)
	at org.eclipse.ui.internal.Workbench$3$1.applicationRunning(Workbench.java:802)
	at org.eclipse.equinox.internal.app.EclipseAppHandle$1.run(EclipseAppHandle.java:279)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.applicationRunning(EclipseAppHandle.java:267)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1092)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-20 10:51:52.192
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-07-05 09:57:57.289 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-07-05 09:58:03.430
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-07-05 09:58:03.430
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6acb45c1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@294c44b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-07-05 09:58:11.366
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\manul'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
